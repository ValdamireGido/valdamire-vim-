" syntax higlighing 
syntax on
filetype on

" Some small configs
" Number and relative number setting
set tabstop=4
set shiftwidth=4
set number relativenumber
set incsearch
set hlsearch
set nowrap
set cursorline

hi CursorLine cterm=NONE ctermbg=darkred ctermfg=NONE

" Quit Vim shorcut
command Q :qa!

" Leader settings
let mapleader = "\<space>"

set backupdir=./.backup/,$HOME/.backup// 
set directory=./.swp/,$HOME/.swp//
set undodir=./.undo/,$HOME/.undo//

set errorfile=$HOME/.tmp/error.err


" Pathogen
execute pathogen#infect()


" Session saving settings
let g:session_directory='.vim'
let g:session_lock_directory='.vim/lock'
let g:session_lock_enabled = 0
let g:session_default_name = 'session'
let g:session_autoload = 'yes'
let g:session_autosave = 'no'

function QuitWithSaving()
	:SaveSession
	:qa!
endfunction
command QS call QuitWithSaving()

if !exists("autocmds_loaded")
	let autocmds_loadeed = 1
	autocmd VimEnter * OpenSession
endif



" NERDTree settings
map <leader>f :NERDTreeToggle<CR> :NERDTreeRefreshRoot<CR>
map <leader>F :NERDTreeFocus<CR>
map <leader>tf :NERDTreeFind<CR>
autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif
autocmd FileType nerdtree setlocal relativenumber " enable line numbers
let g:NERDTreeShowLineNumbers = 1      " make sure relative line numbers are used
let g:NERDTreeMapActivateNode = 'l'    " vifm like open node on 'l'
let g:NERDTreeMapOpenRecursively = 'L' " open node recursively 


command! -complete=shellcmd -nargs=+ Sh      AsyncRun -raw <args>
command! -complete=shellcmd -nargs=+ Shell   AsyncRun -raw <args>
command! -complete=file     -nargs=+ Git     Sh git <args>
command! -complete=file     -nargs=+ Svn     Sh svn <args>
command! -complete=file              SvnInfo Svn info %


" OmniCppComplete
let OmniCpp_NamespaceSearch = 1
let OmniCpp_GlobalScopeSearch = 1
let OmniCpp_ShowAccess = 1
let OmniCpp_ShowPrototypeInAbbr = 1 " show function parameters
let OmniCpp_MayCompleteDot = 1 " autocomplete after .
let OmniCpp_MayCompleteArrow = 1 " autocomplete after ->
let OmniCpp_MayCompleteScope = 1 " autocomplete after ::
let OmniCpp_DefaultNamespaces = ["std", "_GLIBCXX_STD"]
" automatically open and close the popup menu / preview window
au CursorMovedI,InsertLeave * if pumvisible() == 0|silent! pclose|endif
set completeopt=menuone,menu,longest,preview


" GREP shortcut 
command GREP :execute 'vimgrep /'.expand('<cword>').'/gj '.expand('%') | copen


" Ctags file generation 
command! -complete=file -nargs=* GenerateCtags :!ctags -R --sort=yes --c++-kinds=+p --fields=+iaS --extra=+q .<CR>

" Tags file settings
set tags=tags;
set noautochdir


" Otherwise use the special 'diffexpr' for Windows.
if &diffopt !~# 'internal'
  set diffexpr=MyDiff()
endif
function MyDiff()
  let opt = '-a --binary '
  if &diffopt =~ 'icase' | let opt = opt . '-i ' | endif
  if &diffopt =~ 'iwhite' | let opt = opt . '-b ' | endif
  let arg1 = v:fname_in
  if arg1 =~ ' ' | let arg1 = '"' . arg1 . '"' | endif
  let arg1 = substitute(arg1, '!', '\!', 'g')
  let arg2 = v:fname_new
  if arg2 =~ ' ' | let arg2 = '"' . arg2 . '"' | endif
  let arg2 = substitute(arg2, '!', '\!', 'g')
  let arg3 = v:fname_out
  if arg3 =~ ' ' | let arg3 = '"' . arg3 . '"' | endif
  let arg3 = substitute(arg3, '!', '\!', 'g')
  if $VIMRUNTIME =~ ' '
    if &sh =~ '\<cmd'
      if empty(&shellxquote)
        let l:shxq_sav = ''
        set shellxquote&
      endif
      let cmd = '"' . $VIMRUNTIME . '\diff"'
    else
      let cmd = substitute($VIMRUNTIME, ' ', '" ', '') . '\diff"'
    endif
  else
    let cmd = $VIMRUNTIME . '\diff'
  endif
  let cmd = substitute(cmd, '!', '\!', 'g')
  silent execute '!' . cmd . ' ' . opt . arg1 . ' ' . arg2 . ' > ' . arg3
  if exists('l:shxq_sav')
    let &shellxquote=l:shxq_sav
  endif
endfunction


" ex command for toggling hex mode - define mapping if desired
command -bar Hexmode call ToggleHex()


" helper function to toggle hex mode
function ToggleHex()
  " hex mode should be considered a read-only operation
  " save values for modified and read-only for restoration later,
  " and clear the read-only flag for now
  let l:modified=&mod
  let l:oldreadonly=&readonly
  let &readonly=0
  let l:oldmodifiable=&modifiable
  let &modifiable=1
  if !exists("b:editHex") || !b:editHex
    " save old options
    let b:oldft=&ft
    let b:oldbin=&bin
    " set new options
    setlocal binary " make sure it overrides any textwidth, etc.
    silent :e " this will reload the file without trickeries 
              "(DOS line endings will be shown entirely )
    let &ft="xxd"
    " set status
    let b:editHex=1
    " switch to hex editor
    %!xxd
  else
    " restore old options
    let &ft=b:oldft
    if !b:oldbin
      setlocal nobinary
    endif
    " set status
    let b:editHex=0
    " return to normal editing
    %!xxd -r
  endif
  " restore values for modified and read only state
  let &mod=l:modified
  let &readonly=l:oldreadonly
  let &modifiable=l:oldmodifiable
endfunction


" change current working dir to file's working dir
command CDC cd %:p:h
command CDP cd -


" maps for Hexmode 
nnoremap <C-H> :Hexmode<CR>
inoremap <C-H> <Esc>:Hexmode<CR>
vnoremap <C-H> :<C-U>Hexmode<CR>


" nohl hotkey
nnoremap <ESC><ESC> :nohl<CR>
 

" FSwitch mappings
map <C-k><C-j> :FSHere<CR>
map <C-k><C-l> :FSSplitRight<CR>
map <C-k><C-h> :FSSplitLeft<CR>


" FZF binding 
let g:fzf_command_prefix = 'Fzf'
nnoremap <C-t> :FzfFiles<CR>
nnoremap <C-t>f :FzfFiles 
nnoremap <C-t>m :FzfMarks<CR>
nnoremap <C-t>l :FzfBLines<CR>
nnoremap <C-t>L :FzfLines<CR>
nnoremap <C-t>b :FzfBuffers<CR>
nnoremap <C-t>w :FzfWindows<CR>
nnoremap <C-t>t :FzfBTags<CR>
nnoremap <C-t>T :FzfTags<CR>
nnoremap <C-t>h :FzfHistory<CR>

" Clang format mappings and settings
nnoremap <C-k><C-f> :ClangFormat<CR>
vnoremap <C-k><C-f> :ClangFormat<CR>
let g:clang_format#detect_style_file = 1
let g:clang_format#auto_format = 0
let g:clang_format#auto_format_on_insert_leave = 0


" Custom mappings for editing
map K i<CR><ESC>
map <leader>n :cn<CR>
map <leader>p :cp<CR>
map <leader>o :copen<CR>
map <leader>c :cclose<CR>
map <leader>r :cr<CR>


" Buffers controls
map <leader>bn :bn<cr>
map <leader>bp :bp<cr>
map <leader>bl :ls<cr>
map <leader>bd :bdelete<cr>


" Some special optional settings 
if has("gui_running")
	colorscheme darkblue
	set guioptions -=T
else
	"set term=xterm
	set mouse=a
	set nocompatible
endif


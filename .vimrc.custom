" syntax higlighing 
syntax on
filetype on

" Some small configs
" Number and relative number setting
set tabstop=4
set shiftwidth=4
set scrolloff=5
set number relativenumber
set incsearch
set hlsearch
set nowrap
set cursorline
" Some small conursorline
hi CursorLine cterm=NONE ctermbg=darkred ctermfg=NONE


"
" Leader settings
let mapleader = "\<space>"

set backupdir=./.backup/,$HOME/.backup// 
set directory=./.swp/,$HOME/.swp//
set undodir=./.undo/,$HOME/.undo//
set errorfile=$HOME/.tmp/error.err


"
" Vim Plug entries
"
call plug#begin('~/.vim/plugged')

" 
" FZF 
if has('windows') 
	Plug '/c/ProgramData/chocolatey/bin/fzf', { 'dir': '~/.fzf', 'do': './install --all' }
elseif has("unix")
	Plug '/usr/local/opt/fzf', { 'dir': '~/.fzf', 'do': './install --all' }
endif
Plug 'junegunn/fzf.vim'
let g:fzf_command_prefix = 'Fzf'
nnoremap <C-t>  :FzfFiles<CR>
nnoremap <C-t>f :FzfFiles 
nnoremap <C-t>m :FzfMarks<CR>
nnoremap <C-t>l :FzfBLines<CR>
nnoremap <C-t>L :FzfLines<CR>
nnoremap <C-t>b :FzfBuffers<CR>
nnoremap <C-t>w :FzfWindows<CR>
nnoremap <C-t>t :FzfBTags<CR>
nnoremap <C-t>T :FzfTags<CR>
nnoremap <C-t>h :FzfHistory<CR>

"
" Vim grepper
Plug 'mhinz/vim-grepper'
nnoremap <leader>s :Grepper -tool ag -highlight<CR>
nnoremap <leader>S :Grepper -tool ag -buffers -highlight<CR>
nnoremap <leader>g :Grepper -tool grep -highlight<CR>
nnoremap <leader>G :Grepper -tool grep -buffers -highlight<CR>
nmap gs <plug>(GrepperOperator)
xmap gs <plug>(GrepperOperator)

" 
" Nuake
Plug 'Lenovsky/nuake'
nnoremap <F4> :Nuake<CR>
inoremap <F4> <C-\><C-n>:Nuake<CR>
tnoremap <F4> <C-\><C-n>:Nuake<CR>


"
" Multiple cursor 
let g:multi_cursor_use_default_mapping = 0
Plug 'terryma/vim-multiple-cursors'
let g:multi_cursor_select_all_word_key = '<C-a>'
let g:multi_cursos_select_all_key      = 'g<C-a>'


call plug#end()


"
" Pathogen
execute pathogen#infect()


"
" Basic movement and often used commands
command Q :qa!

function QuitWithSaving()
	:SaveSession
	:qa!
endfunction
command QS call QuitWithSaving()

nnoremap <C-.> :<UP><CR>

nnoremap <C-J> <C-W>j
tnoremap <C-J> <C-\><C-n><C-W>j
nnoremap <C-K> <C-W>k
tnoremap <C-K> <C-\><C-n><C-W>k
nnoremap <C-H> <C-W>h
tnoremap <C-H> <C-\><C-n><C-W>h
nnoremap <C-L> <C-W>l
tnoremap <C-L> <C-\><C-n><C-W>l


"
" Copy/Paste
nnoremap <S-Insert> "+p
inoremap <S-Insert> "+p
vnoremap <S-Insert> "+p
nnoremap <C-Insert> "+y
inoremap <C-Insert> "+y
vnoremap <C-Insert> "+y


"
" Colemak specific stuff
nnoremap <A-n> j
nnoremap <A-e> k
nnoremap <A-i> l


"
" Session saving settings
let g:session_directory      ='.vim'
let g:session_lock_directory ='.vim/lock'
let g:session_lock_enabled   = 0
let g:session_default_name   = 'session'
let g:session_autoload       = 'no'
let g:session_autosave       = 'no'
let g:session_persist_font   = 0
let g:session_persist_colors = 0

fu! Custom_OpenSession()
	if argc() == 0
		:OpenSession
		if bufexists(1)
		  for l in range(1, bufnr('$'))
			if bufwinnr(l) == -1
			  exec 'sbuffer ' . l
			endif
		  endfor
		endif
	endif
endfunction


if !exists("autocmds_loaded")
	let autocmds_loadeed = 1
	autocmd VimEnter * nested call Custom_OpenSession()
endif


"
" NERDTree settings
map <F3> :NERDTreeToggle<CR>
map <F3><F3> :NERDTreeFocus<CR>
map <F3>f :NERDTreeFind<CR>
autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif
autocmd FileType nerdtree setlocal relativenumber " enable line numbers
let g:NERDTreeShowLineNumbers = 1      " make sure relative line numbers are used
let g:NERDTreeMapActivateNode = 'l'    " vifm like open node on 'l'
let g:NERDTreeMapOpenRecursively = 'L' " open node recursively 


command! -complete=shellcmd -nargs=+ Sh        AsyncRun -raw <args>
command! -complete=shellcmd -nargs=+ Shell     AsyncRun -raw <args>
command! -complete=file     -nargs=+ Git       Sh git <args>
command! -complete=file     -nargs=+ GitStatus Sh git status <args>
command! -complete=file     -nargs=+ Svn       Sh svn <args>
command! -complete=file              SvnInfo   Svn info %


" OmniCppComplete
let OmniCpp_NamespaceSearch = 1
let OmniCpp_GlobalScopeSearch = 1
let OmniCpp_ShowAccess = 1
let OmniCpp_ShowPrototypeInAbbr = 1 " show function parameters
let OmniCpp_MayCompleteDot = 1 " autocomplete after .
let OmniCpp_MayCompleteArrow = 1 " autocomplete after ->
let OmniCpp_MayCompleteScope = 1 " autocomplete after ::
let OmniCpp_DefaultNamespaces = ["std", "_GLIBCXX_STD"]
" automatically open and close the popup menu / preview window
au CursorMovedI,InsertLeave * if pumvisible() == 0|silent! pclose|endif
set completeopt=menuone,menu,longest,preview


" Ctags file generation 
command! -complete=file -nargs=* GenerateCtags :!ctags -R --sort=yes --c++-kinds=+p --fields=+iaS --extra=+q .<CR>


" Tags file settings
set tags=tags;
set noautochdir


" Otherwise use the special 'diffexpr' for Windows.
if &diffopt !~# 'internal'
  set diffexpr=MyDiff()
endif
function MyDiff()
  let opt = '-a --binary '
  if &diffopt =~ 'icase' | let opt = opt . '-i ' | endif
  if &diffopt =~ 'iwhite' | let opt = opt . '-b ' | endif
  let arg1 = v:fname_in
  if arg1 =~ ' ' | let arg1 = '"' . arg1 . '"' | endif
  let arg1 = substitute(arg1, '!', '\!', 'g')
  let arg2 = v:fname_new
  if arg2 =~ ' ' | let arg2 = '"' . arg2 . '"' | endif
  let arg2 = substitute(arg2, '!', '\!', 'g')
  let arg3 = v:fname_out
  if arg3 =~ ' ' | let arg3 = '"' . arg3 . '"' | endif
  let arg3 = substitute(arg3, '!', '\!', 'g')
  if $VIMRUNTIME =~ ' '
    if &sh =~ '\<cmd'
      if empty(&shellxquote)
        let l:shxq_sav = ''
        set shellxquote&
      endif
      let cmd = '"' . $VIMRUNTIME . '\diff"'
    else
      let cmd = substitute($VIMRUNTIME, ' ', '" ', '') . '\diff"'
    endif
  else
    let cmd = $VIMRUNTIME . '\diff'
  endif
  let cmd = substitute(cmd, '!', '\!', 'g')
  silent execute '!' . cmd . ' ' . opt . arg1 . ' ' . arg2 . ' > ' . arg3
  if exists('l:shxq_sav')
    let &shellxquote=l:shxq_sav
  endif
endfunction


" ex command for toggling hex mode - define mapping if desired
command -bar Hex call ToggleHex()


" helper function to toggle hex mode
function ToggleHex()
  " hex mode should be considered a read-only operation
  " save values for modified and read-only for restoration later,
  " and clear the read-only flag for now
  let l:modified=&mod
  let l:oldreadonly=&readonly
  let &readonly=0
  let l:oldmodifiable=&modifiable
  let &modifiable=1
  if !exists("b:editHex") || !b:editHex
    " save old options
    let b:oldft=&ft
    let b:oldbin=&bin
    " set new options
    setlocal binary " make sure it overrides any textwidth, etc.
    silent :e " this will reload the file without trickeries 
              "(DOS line endings will be shown entirely )
    let &ft="xxd"
    " set status
    let b:editHex=1
    " switch to hex editor
    %!xxd
  else
    " restore old options
    let &ft=b:oldft
    if !b:oldbin
      setlocal nobinary
    endif
    " set status
    let b:editHex=0
    " return to normal editing
    %!xxd -r
  endif
  " restore values for modified and read only state
  let &mod=l:modified
  let &readonly=l:oldreadonly
  let &modifiable=l:oldmodifiable
endfunction


" change current working dir to file's working dir
command CDC cd %:p:h
command CDP cd -


" nohl hotkey
nnoremap <ESC><ESC> :nohl<CR>
tnoremap <ESC><ESC> <C-\><C-n>
 

" FSwitch mappings
map <C-;><C-.> :FSHere<CR>
map <C-;><C-j> :FSSplitBellow<CR>
map <C-;><C-k> :FSSplitAbove<CR>
map <C-;><C-l> :FSSplitRight<CR>
map <C-;><C-h> :FSSplitLeft<CR>


" Clang format mappings and settings
nnoremap <leader>f :ClangFormat<CR>
vnoremap <leader>f :ClangFormat<CR>
let g:clang_format#detect_style_file = 1
let g:clang_format#auto_format = 0
let g:clang_format#auto_format_on_insert_leave = 0


" Custom mappings for editing
map K i<CR><ESC>
map <leader>n :cn<CR>
map <leader>p :cp<CR>
map <leader>o :copen<CR>
map <leader>c :cclose<CR>
map <leader>r :cr<CR>


" Buffers controls
map <leader>bn :bn<cr>
map <leader>bp :bp<cr>
map <leader>bl :ls<cr>
map <leader>bd :bdelete<cr>


" Some special optional settings 
if has("gui_running")
	colorscheme darkblue
	set guioptions -=T
else
	"set term=xterm
	set mouse=a
	set nocompatible
endif


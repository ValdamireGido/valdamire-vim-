" syntax higlighing 
syntax on

" Some small configs
" Number and relative number setting
set tabstop=4
set shiftwidth=4
set number relativenumber
set incsearch
set hlsearch


" swap backup and undo dirs settings 
silent !mkdir $HOME/.backup > /dev/null 2>&1
silent !mkdir $HOME/.swp > /dev/null 2>&1
silent !mkdir $HOME/.undo > /dev/null 2>&1
silent !mkdir ./.backup > /dev/null 2>&1
silent !mkdir ./.swp > /dev/null 2>&1
silent !mkdir ./.undo > /dev/null 2>&1

set backupdir=./.backup/,$HOME/.backup// 
set directory=./.swp/,$HOME/.swp//
set undodir=./.undo/,$HOME/.undo//

set errorfile=$HOME/.tmp/error.err


" Pathogen
execute pathogen#infect()


" NERDTree settings
map <C-L> :NERDTreeToggle<CR>
autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif
autocmd FileType nerdtree setlocal relativenumber " enable line numbers

let NERDTreeShowLineNumbers=1      " make sure relative line numbers are used

" Run shell cmd in new window
function! s:ExecuteInShell(command)
   	let command = join(map(split(a:command), 'expand(v:val)'))
   	let winnr = bufwinnr('^' . command . '$')
   	silent! execute  winnr < 0 ? 'botright new ' . fnameescape(command) : winnr . 'wincmd w'
   	setlocal buftype=nowrite bufhidden=wipe nobuflisted noswapfile nowrap number
   	echo 'Execute ' . command . '...'
   	silent! execute 'silent %!'. command
   	silent! execute 'resize ' . line('$')
   	silent! redraw
   	silent! execute 'au BufUnload <buffer> execute bufwinnr(' . bufnr('#') . ') . ''wincmd w'''
   	silent! execute 'nnoremap <silent> <buffer> <LocalLeader>r :call <SID>ExecuteInShell(''' . command . ''')<CR>'
   	echo 'Shell command ' . command . ' executed.'
endfunction
command! -complete=shellcmd -nargs=+ Shell call s:ExecuteInShell(<q-args>)

" Cutsom Shell shortcuts
command! -complete=file -nargs=* Git call s:ExecuteInShell('git '.<q-args>) 
command! -complete=file -nargs=* Svn call s:ExecuteInShell('svn '.<q-args>)


" OmniCppComplete
let OmniCpp_NamespaceSearch = 1
let OmniCpp_GlobalScopeSearch = 1
let OmniCpp_ShowAccess = 1
let OmniCpp_ShowPrototypeInAbbr = 1 " show function parameters
let OmniCpp_MayCompleteDot = 1 " autocomplete after .
let OmniCpp_MayCompleteArrow = 1 " autocomplete after ->
let OmniCpp_MayCompleteScope = 1 " autocomplete after ::
let OmniCpp_DefaultNamespaces = ["std", "_GLIBCXX_STD"]
" automatically open and close the popup menu / preview window
au CursorMovedI,InsertLeave * if pumvisible() == 0|silent! pclose|endif
set completeopt=menuone,menu,longest,preview


" GREP shortcut 
command GREP :execute 'vimgrep /'.expand('<cword>').'/gj '.expand('%') | copen


" Ctags file generation 
command! -complete=file -nargs=* GenerateCtags :!ctags -R --sort=yes --c++-kinds=+p --fields=+iaS --extra=+q .<CR>

" Tags file settings
set tags=tags;
set noautochdir
"set autochdir


" Otherwise use the special 'diffexpr' for Windows.
if &diffopt !~# 'internal'
  set diffexpr=MyDiff()
endif
function MyDiff()
  let opt = '-a --binary '
  if &diffopt =~ 'icase' | let opt = opt . '-i ' | endif
  if &diffopt =~ 'iwhite' | let opt = opt . '-b ' | endif
  let arg1 = v:fname_in
  if arg1 =~ ' ' | let arg1 = '"' . arg1 . '"' | endif
  let arg1 = substitute(arg1, '!', '\!', 'g')
  let arg2 = v:fname_new
  if arg2 =~ ' ' | let arg2 = '"' . arg2 . '"' | endif
  let arg2 = substitute(arg2, '!', '\!', 'g')
  let arg3 = v:fname_out
  if arg3 =~ ' ' | let arg3 = '"' . arg3 . '"' | endif
  let arg3 = substitute(arg3, '!', '\!', 'g')
  if $VIMRUNTIME =~ ' '
    if &sh =~ '\<cmd'
      if empty(&shellxquote)
        let l:shxq_sav = ''
        set shellxquote&
      endif
      let cmd = '"' . $VIMRUNTIME . '\diff"'
    else
      let cmd = substitute($VIMRUNTIME, ' ', '" ', '') . '\diff"'
    endif
  else
    let cmd = $VIMRUNTIME . '\diff'
  endif
  let cmd = substitute(cmd, '!', '\!', 'g')
  silent execute '!' . cmd . ' ' . opt . arg1 . ' ' . arg2 . ' > ' . arg3
  if exists('l:shxq_sav')
    let &shellxquote=l:shxq_sav
  endif
endfunction


" ex command for toggling hex mode - define mapping if desired
command -bar Hexmode call ToggleHex()


" helper function to toggle hex mode
function ToggleHex()
  " hex mode should be considered a read-only operation
  " save values for modified and read-only for restoration later,
  " and clear the read-only flag for now
  let l:modified=&mod
  let l:oldreadonly=&readonly
  let &readonly=0
  let l:oldmodifiable=&modifiable
  let &modifiable=1
  if !exists("b:editHex") || !b:editHex
    " save old options
    let b:oldft=&ft
    let b:oldbin=&bin
    " set new options
    setlocal binary " make sure it overrides any textwidth, etc.
    silent :e " this will reload the file without trickeries 
              "(DOS line endings will be shown entirely )
    let &ft="xxd"
    " set status
    let b:editHex=1
    " switch to hex editor
    %!xxd
  else
    " restore old options
    let &ft=b:oldft
    if !b:oldbin
      setlocal nobinary
    endif
    " set status
    let b:editHex=0
    " return to normal editing
    %!xxd -r
  endif
  " restore values for modified and read only state
  let &mod=l:modified
  let &readonly=l:oldreadonly
  let &modifiable=l:oldmodifiable
endfunction


" maps for Hexmode 
nnoremap <C-H> :Hexmode<CR>
inoremap <C-H> <Esc>:Hexmode<CR>
vnoremap <C-H> :<C-U>Hexmode<CR>


" nohl hotkey
nnoremap <ESC><ESC> :nohl<CR>
 

" FSwitch mappings
map <C-k><C-j> :FSHere<CR>
map <C-k><C-l> :FSSplitRight<CR>
map <C-k><C-h> :FSSplitLeft<CR>


" Clang format mappings and settings
nnoremap <C-k><C-f> :ClangFormat<CR>
vnoremap <C-k><C-f> :ClangFormat<CR>
let g:clang_format#detect_style_file = 1
let g:clang_format#auto_format = 0
let g:clang_format#auto_format_on_insert_leave = 0


" Some cpp specific stuff


" Custom mappings for editing
map K i<CR><ESC>
let mapleader = "\<space>"
map <leader>n :cn<CR>
map <leader>p :cp<CR>
map <leader>o :copen<CR>
map <leader>c :cclose<CR>
map <leader>r :cr<CR>

" Buffers controls
map <leader>bn :bn<cr>
map <leader>bp :bp<cr>
map <leader>bl :ls<cr>
map <leader>bd :bdelete<cr>

" Autocommands


" Lightline settings


" Some special optional settings 
if has("gui_running")
	colorscheme darkblue
	set guioptions -=T
endif
